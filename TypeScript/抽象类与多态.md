# 抽象类 

- 用 abstract 关键字定义抽象类和抽象方法，在抽象类中抽象方法不包含具体实现必须在派生类中实现

- 抽象类和抽象方法一般用来定义某种标准，可以用来实现多态
- 抽象类中可以有实例方法，但是必须包含一个抽象方法，否则没有意义
- 抽象方法只能存在于抽象类中
- 继承抽象类的子类，必须实现抽象类中定义的抽象方法
- 抽象类无法被实例化

```js
//抽象类
abstract classs Animal {
    public name:string
    constructor(name:string) {
        this.name = name
    }
    abstract eat():any //抽象方法
}
const animal = new Animal("动物") // 报错 抽象类无法被实例化
//派生类去实现抽象类
class Cat extends Animal {
    constructor(name:string) {
        this.name = name
    }
    //子类必须去实现 继承抽象类的抽象方法 否则报错
    eat():any {
        console.log("小猫的吃饭方法")
    }
    abstract fn():void{}//报错 抽象方法只能在抽象类中定义
}
```

# 多态

- 函数重载
- 父类定义一个方法不去实现，让继承他的子类去实现，每一个子类有不同的表现
```js
class Futher {
    public age: number;
    constructor(age: number) {
        this.age = age
    }
    counts(): void {
        console.log(this.age)
    }
}
class children1 extends Futher {
    constructor(age: number) {
        super(age)
    }
    counts(): void {    /* 多态，重写方法不执行父类方法 */
        console.log(this.age - 1)
    }
}
class children2 extends Futher {
    constructor(age: number) {
        super(age)
    }
    counts(): void {
        console.log(this.age + 1)
    }
}
```