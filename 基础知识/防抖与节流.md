# 防抖与节流

## 闭包

闭包是函数与函数可以访问到的自由变量,当函数被销毁的时候,自由变量还被引用未被销毁的现象

## 防抖

![防抖的图片](./imgs/debounce.png)

触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间

- 不会触发第一次
```js
function debounce(fn, wait) {
    let timer = null;
    return function () {
        const args = arguments;
        const context = this;
        if (timer) {
            clearTimeout(timer);
        }

        timer = setTimeout(function() {
            clearTimeout(timer);
            timer = null;
            fn.apply(context, args)
        }, wait);
    }
}
```
- 会触发第一次
```js
function debounce(fn, wait) {
    let timer = null,
        cando = true;

    return function() {
        const args = arguments,
              context = this;

        if (cando) {
            fn.apply(context, args);
            cando = false;
        }

        if (timer) {
            clearTimeout(timer);
        }

        timer = setTimeout(function() {
            cando = true
        }, wait);     
    }
}
```
## 节流
![节流的图片](./src/throttle.png)

高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率

- 定时器版本
```js
function throttle(fn, wait) {
    let timer = null;
    return function() {
        const args = arguments,
              context = this;

        if (!timer) {
            timer = setTimeout(function() {
                fn.apply(context, args);
                timer = null;
                clearTimeout(timer);
            }, wait);
        }
    }
}
```

- 时间戳版本

```js
function throttle(fn, wait) {
    let activeTime = 0;
    return function() {
        const args = arguments,
              context = this;

        const currentTime = Date.now();
        if (currentTime - activeTime > wait) {
            fn.apply(context, args);
            activeTime = Date.now();
        }
    }
}
```